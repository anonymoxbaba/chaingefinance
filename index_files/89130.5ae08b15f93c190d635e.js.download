"use strict";(self.webpackChunktradingview=self.webpackChunktradingview||[]).push([[89130],{100366:(t,e,s)=>{async function n(){return(await Promise.all([s.e(27741),s.e(62564),s.e(58666),s.e(82321),s.e(20139)]).then(s.bind(s,254543))).ErrorCardRenderer}s.d(e,{getErrorCardRenderer:()=>n})},570701:(t,e,s)=>{var n,r;function i(t,e){return"period-back"===t.type&&"period-back"===e.type?t.value===e.value:"time-range"===t.type&&"time-range"===e.type&&(t.from===e.from&&t.to===e.to)}s.d(e,{TIMEFRAMETYPE:()=>r,areEqualTimeFrames:()=>i}),function(t){t.extractErrorReason=function(t){return t.params[1]}}(n||(n={})),function(t){t.PeriodBack="period-back",t.TimeRange="time-range"}(r||(r={}))},307239:(t,e,s)=>{function n(t){if(void 0===t)return null;const e=t.match(/(delayed_streaming)_(\d+)/);return null===e?null:{mode:e[1],interval:parseInt(e[2])}}function r(t){const e=n(t.update_mode);return null===e||(t.update_mode=e.mode,t.update_mode_seconds=e.interval),t}s.r(e),s.d(e,{normalizeUpdateMode:()=>r,parseUpdateMode:()=>n})},828473:(t,e,s)=>{s.d(e,{compareTwoCollectionsByIds:()=>x,findFirst:()=>p,indexOf:()=>g,intersect:()=>_,join:()=>m,lowerbound:()=>a,lowerboundExt:()=>i,mapEntriesGenerator:()=>w,moveAfter:()=>c,moveBefore:()=>d,moveToHead:()=>u,nestedMapGenerator:()=>y,removeItemFromArray:()=>f,subtract:()=>l,sum:()=>b,upperbound:()=>o});var n=s(650151);function r(t,e){return t<e}function i(t,e,s,n,r){let i=r-n;for(;0<i;){const r=i>>1,a=n+r;s(t(a),e)?(n=a+1,i-=r+1):i=r}return n}function a(t,e,s,n=0,r=t.length){return i((e=>t[e]),e,s,n,r)}function h(t,e,s=0,n=t.length){return a(t,e,r,s,n)}function o(t,e,s,n=0,r=t.length){let i=r-n;for(;0<i;){const r=i>>1,a=n+r;s(e,t[a])?i=r:(n=a+1,i-=r+1)}return n}function l(t,e){return t.filter((t=>!e.includes(t)))}function u(t,e){const s=t.indexOf(e);return s<0?t.slice():[e].concat(t.slice(0,s)).concat(t.slice(s+1))}function c(t,e,s){const n=new Set(e),r=[],i=[],a=[];return t.forEach(((t,e)=>{n.has(t)?i.push(t):(r.push(t),a.push(e))})),s=s<t.length-1?h(a,s+1):r.length,r.splice(s,0,...i),{newItems:r,movedItemsStartIndex:s}}function d(t,e,s){const n=new Set(e),r=[],i=[],a=[];return t.forEach(((t,e)=>{n.has(t)?i.push(t):(r.push(t),a.push(e))})),s=s<=t.length-1?h(a,s):r.length,r.splice(s,0,...i),{newItems:r,movedItemsStartIndex:s}}function _(t,e){const s=new Set;return t.forEach((t=>{e.has(t)&&s.add(t)})),s}function m(t,e){const s=new Set(t);return e.forEach((t=>s.add(t))),s}function f(t,e){const s=t.indexOf(e);(0,n.assert)(-1!==s,"Item is not found"),t.splice(s,1)}function p(t,e){for(const s of t)if(e(s))return s;return null}function g(t,e){for(let s=0;s<t.length;s++)if(e(t[s]))return s;return-1}function x(t,e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;++s)if(t[s].id()!==e[s].id())return!1;return!0}function b(t){return t.reduce(((t,e)=>t+e),0)}function*w(t){for(const[e,s]of t)yield[e,s]}function*y(t,e){for(const[s,n]of t)if(void 0===e)for(const[,t]of n)yield[s,t];else{const t=n.get(e);void 0!==t&&(yield[s,t])}}},882782:(t,e,s)=>{s.d(e,{DEFAULT_ADJUSTMENT:()=>r,DEFAULT_SESSION:()=>n,
DEFAULT_SETTLEMENT_AS_CLOSE:()=>i,compareSymbols:()=>f,decodeExtendedSymbol:()=>d,encodeExtendedSymbolOrGetSimpleSymbolString:()=>u,isEncodedExtendedSymbol:()=>c,isReplaySymbol:()=>l,isStudySymbol:()=>o,unwrapSimpleSymbol:()=>_});const n="regular",r="splits",i=!0;function a(t){return"="+JSON.stringify(h(t))}function h(t){return Object.keys(t).sort().reduce(((e,s)=>("[object Object]"===Object.prototype.toString.call(t[s])?e[s]=h(t[s]):e[s]=t[s],e)),{})}function o(t){return Boolean(t.inputs)}function l(t){return Boolean(t.replay)}function u(t){return o(t)||l(t)||t.session||t.adjustment||t["currency-id"]||t["unit-id"]?a(t):t.symbol}function c(t){return"="===t[0]}function d(t){if(!c(t))return{symbol:t};try{return JSON.parse(t.slice(1))}catch(e){return{symbol:t}}}function _(t){return"string"==typeof t?t:_(t.symbol)}const m=["symbol","session","unit-id","currency-id","adjustment","backadjustment","settlement-as-close"];function f(t,e){return m.every((s=>t[s]===e[s]))}},339709:(t,e,s)=>{s.d(e,{customFormatters:()=>n});const n={dateFormatter:null,timeFormatter:null,tickMarkFormatter:null,priceFormatterFactory:null,studyFormatterFactory:null}},55243:(t,e,s)=>{s.d(e,{PlotList:()=>d,mergeMinMax:()=>_});var n=s(650151),r=s(828473),i=s(501571),a=s(338619),h=s(518439);const o=(0,a.getLogger)("Chart.PlotList"),l=30;function u(t){return t.index}function c(t){return t.value[0]}class d{constructor(t=null,e=null){this._items=[],this._start=0,this._end=0,this._shareRead=!1,this._minMaxCache=new Map,this._rowSearchCacheByIndex=new Map,this._rowSearchCacheByIndexWithoutEmptyValues=new Map,this._rowSearchCacheByTime=new Map,this._rowSearchCacheByTimeWithoutEmptyValues=new Map,this._plotFunctions=t||new Map,this._emptyValuePredicate=e}clear(){this._items=[],this._start=0,this._end=0,this._shareRead=!1,this._minMaxCache.clear(),this._invalidateSearchCaches()}first(){return this.size()>0?this._items[this._start]:null}last(){return this.size()>0?this._items[this._end-1]:null}firstIndex(){return this.size()>0?this._indexAt(this._start):null}lastIndex(){return this.size()>0?this._indexAt(this._end-1):null}clone(){const t=this.firstIndex(),e=this.lastIndex();return null===t||null===e?new d:this.range(t,e)}size(){return this._end-this._start}isEmpty(){return 0===this.size()}contains(t){return null!==this.search(t,h.PlotRowSearchMode.Exact)}valueAt(t){const e=this.search(t);return null!==e?e.value:null}add(t,e){if(this._shareRead)return o.logDebug("add: readonly collection modification attempt"),!1;const s={index:t,value:e},n=this._nonCachedSearch(t,h.PlotRowSearchMode.Exact,u);return this._invalidateSearchCaches(),null===n?(this._items.splice(this._lowerbound(t,u),0,s),this._start=0,this._end=this._items.length,!0):(this._items[n]=s,!1)}search(t,e=h.PlotRowSearchMode.Exact,s){return this._searchImpl(t,e,this._rowSearchCacheByIndex,this._rowSearchCacheByIndexWithoutEmptyValues,u,s)}searchByTime(t,e=h.PlotRowSearchMode.Exact,s){return this._searchImpl(t,e,this._rowSearchCacheByTime,this._rowSearchCacheByTimeWithoutEmptyValues,c,s)}fold(t,e){let s=e
;for(let e=this._start;e<this._end;++e){s=t(this._indexAt(e),this._valueAt(e),s)}return s}findFirst(t,e){const s=void 0!==e&&Math.min(this._start+e,this._end)||this._end;for(let e=this._start;e<s;++e){const s=this._indexAt(e),n=this._valueAt(e);if(t(s,n))return{index:s,value:n}}return null}findLast(t,e){const s=void 0!==e&&Math.max(this._end-e,this._start)||this._start;for(let e=this._end-1;e>=s;--e){const s=this._indexAt(e),n=this._valueAt(e);if(t(s,n))return{index:s,value:n}}return null}each(t){for(let e=this._start;e<this._end;++e){if(t(this._indexAt(e),this._valueAt(e)))break}}reduce(t,e){let s=e;for(let e=this._start;e<this._end;++e){s=t(s,this._indexAt(e),this._valueAt(e))}return s}range(t,e){const s=new d(this._plotFunctions,this._emptyValuePredicate);return s._items=this._items,s._start=this._lowerbound(t,u),s._end=this._upperbound(e),s._shareRead=!0,s}plottableRange(t){const e=new d(this._plotFunctions,this._emptyValuePredicate);return e._items=this._items,e._start=this._upperbound(i.UNPLOTTABLE_TIME_POINT_INDEX),e._end=this._end,e._shareRead=!0,!0===t&&e._start>this._start&&(e._start-=1),e}rangeCountback(t,e){if(null===this.firstIndex())return new d;const s=new d(this._plotFunctions,this._emptyValuePredicate);return s._items=this._items,s._end=this._upperbound(t),s._start=Math.max(this._start,s._end-e),s._shareRead=!0,s}rangeIterator(t,e){const s=this._lowerbound(t,u),n=this._upperbound(e);return this._rangeIteratorImpl(s,n)}fullRangeIterator(){return this._rangeIteratorImpl(this._start,this._end)}minMaxOnRangeCached(t,e,s){if(this.isEmpty())return null;let n=null;for(const r of s){n=_(n,this._minMaxOnRangeCachedImpl(t-r.offset,e-r.offset,r.name))}return n}minMaxOnRange(t,e,s){if(this.isEmpty())return null;let n=null;for(const r of s){n=_(n,this._minMaxOnRange(t-r.offset,e-r.offset,r.name))}return n}merge(t){return this._shareRead?(o.logDebug("merge: readonly collection modification attempt"),null):0===t.length?null:this.isEmpty()||t[t.length-1].index<this._items[0].index?this._prepend(t):t[0].index>this._items[this._items.length-1].index?this._append(t):1===t.length&&t[0].index===this._items[this._items.length-1].index?(this._updateLast(t[0]),t[0]):this._merge(t)}addTail(t,e=!1){if(0===t.length)return;let s=0;e&&this._end-this._start>0&&(s=1,this._items[this._end-this._start-1].value=t[0].value);for(let e=s;e<t.length;++e){const s=t[e],n=this.lastIndex();if(null===n){o.logError("Can't add tail to the empty plotlist");break}this.add(n+1,s.value)}this._invalidateSearchCaches()}move(t){if(this._shareRead)return void o.logDebug("move: readonly collection modification attempt");if(0===t.length)return;const e=this._items.slice();for(const s of t){const t=this._bsearch(s.old,u);if(null!==t&&void 0!==e[t])if(s.new===i.INVALID_TIME_POINT_INDEX)e[t]=void 0;else{e[t]={index:s.new,value:e[t].value};const n=this._bsearch(s.new,u);if(null!==n){const t=e[n];void 0!==t&&t.index===s.new&&(e[n]=void 0)}}}this._items=e.filter((t=>void 0!==t)).sort(((t,e)=>t.index-e.index)),this._invalidateSearchCaches(),
this._minMaxCache.clear(),this._start=0,this._end=this._items.length}remove(t){if(this._shareRead)return o.logDebug("remove: readonly collection modification attempt"),null;const e=this._nonCachedSearch(t,h.PlotRowSearchMode.NearestRight,u);if(null===e)return null;const s=this._items.splice(e);return this._end=this._items.length,this._minMaxCache.clear(),this._invalidateSearchCaches(),s.length>0?s[0]:null}state(){const t=this._items.slice(this._start,this._end);return{start:0,end:t.length,data:t}}restoreState(t){t?(this._start=t.start,this._end=t.end,this._shareRead=!1,this._items=t.data,this._minMaxCache.clear(),this._invalidateSearchCaches()):this.clear()}_indexAt(t){return this._items[t].index}_valueAt(t){return this._items[t].value}_length(){return this._items.length}_searchImpl(t,e,s,n,r,i){const a=void 0!==i?s:n,h=void 0!==i?1e4*(e+1)+i:e;let o=a.get(t);if(void 0!==o){const t=o.get(h);if(void 0!==t)return t}const l=this._nonCachedSearch(t,e,r,i);if(null===l)return null;const u={index:this._indexAt(l),value:this._valueAt(l)};return void 0===o&&(o=new Map,a.set(t,o)),o.set(h,u),u}_nonCachedSearch(t,e,s,n){const r=this._lowerbound(t,s),i=r===this._end||t!==s(this._items[r]);if(i&&e!==h.PlotRowSearchMode.Exact)switch(e){case h.PlotRowSearchMode.NearestLeft:return this._searchNearestLeft(r,n);case h.PlotRowSearchMode.NearestRight:return this._searchNearestRight(r,n);default:throw new TypeError("Unknown search mode")}if(void 0===n||i||e===h.PlotRowSearchMode.Exact)return i?null:r;switch(e){case h.PlotRowSearchMode.NearestLeft:return this._nonEmptyNearestLeft(r,n);case h.PlotRowSearchMode.NearestRight:return this._nonEmptyNearestRight(r,n);default:throw new TypeError("Unknown search mode")}}_nonEmptyNearestRight(t,e){const s=(0,n.ensure)(this._emptyValuePredicate),r=(0,n.ensure)(e);for(;t<this._end&&s(this._valueAt(t),r);)t+=1;return t===this._end?null:t}_nonEmptyNearestLeft(t,e){const s=(0,n.ensureNotNull)(this._emptyValuePredicate),r=(0,n.ensure)(e);for(;t>=this._start&&s(this._valueAt(t),r);)t-=1;return t<this._start?null:t}_searchNearestLeft(t,e){if(t===this._start)return null;const s=t-1,n=s!==this._end?s:null;return void 0!==e&&null!==n?this._nonEmptyNearestLeft(n,e):n}_searchNearestRight(t,e){const s=t,n=s!==this._end?s:null;return void 0!==e&&null!==n?this._nonEmptyNearestRight(n,e):n}_bsearch(t,e){const s=this._lowerbound(t,e);return s!==this._end&&t===e(this._items[s])?s:null}_lowerbound(t,e){return(0,r.lowerbound)(this._items,t,((t,s)=>e(t)<s),this._start,this._end)}_upperbound(t){return(0,r.upperbound)(this._items,t,((t,e)=>e.index>t),this._start,this._end)}_plotMinMax(t,e,s){let n=null;const r=this._plotFunctions.get(s);if(void 0===r)throw new Error(`Plot "${s}" is not registered`);for(let s=t;s<e;s++){const t=r(this._items[s].value);null==t||Number.isNaN(t)||(null===n?n={min:t,max:t}:(t<n.min&&(n.min=t),t>n.max&&(n.max=t)))}return n}_invalidateCacheForRow(t){const e=Math.floor(t.index/l);this._minMaxCache.forEach((t=>t.delete(e)))}_prepend(t){return(0,
n.assert)(!this._shareRead,"collection should not be readonly"),(0,n.assert)(0!==t.length,"plotRows should not be empty"),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._items=t.concat(this._items),this._start=0,this._end=this._items.length,t[0]}_append(t){return(0,n.assert)(!this._shareRead,"collection should not be readonly"),(0,n.assert)(0!==t.length,"plotRows should not be empty"),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._items=this._items.concat(t),this._start=0,this._end=this._items.length,t[0]}_updateLast(t){(0,n.assert)(!this.isEmpty(),"plot list should not be empty");const e=this._items[this._end-1];(0,n.assert)(e.index===t.index,"last row index should match new row index"),this._invalidateCacheForRow(t),this._invalidateSearchCaches(),this._items[this._end-1]=t}_merge(t){return(0,n.assert)(0!==t.length,"plot rows should not be empty"),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._items=function(t,e){const s=function(t,e){const s=t.length,n=e.length;let r=s+n,i=0,a=0;for(;i<s&&a<n;)t[i].index<e[a].index?i++:t[i].index>e[a].index?a++:(i++,a++,r--);return r}(t,e),n=new Array(s);let r=0,i=0;const a=t.length,h=e.length;let o=0;for(;r<a&&i<h;)t[r].index<e[i].index?(n[o]=t[r],r++):t[r].index>e[i].index?(n[o]=e[i],i++):(n[o]=e[i],r++,i++),o++;for(;r<a;)n[o]=t[r],r++,o++;for(;i<h;)n[o]=e[i],i++,o++;return n}(this._items,t),this._start=0,this._end=this._items.length,t[0]}_minMaxOnRangeCachedImpl(t,e,s){if(this.isEmpty())return null;let r=null;const i=(0,n.ensureNotNull)(this.firstIndex()),a=(0,n.ensureNotNull)(this.lastIndex()),h=Math.max(t,i),o=Math.min(e,a),u=Math.ceil(h/l)*l,c=Math.max(u,Math.floor(o/l)*l);r=_(r,this._minMaxOnRange(h,Math.min(u,e,o),s));let d=this._minMaxCache.get(s);void 0===d&&(d=new Map,this._minMaxCache.set(s,d));for(let t=Math.max(u+1,h);t<c;t+=l){const e=Math.floor(t/l);let n=d.get(e);if(void 0===n){const t=e*l,r=(e+1)*l-1;n=this._minMaxOnRange(t,r,s),d.set(e,n)}r=_(r,n)}r=_(r,this._minMaxOnRange(c,o,s));return r}_minMaxOnRange(t,e,s){return this._plotMinMax(this._lowerbound(t,u),this._upperbound(e),s)}_rangeIteratorImpl(t,e){let s=t-1;return{[Symbol.iterator](){return this},next:()=>(s+=1,s>=e?{done:!0,value:void 0}:{done:!1,value:this._items[s]})}}_invalidateSearchCaches(){this._rowSearchCacheByIndex.clear(),this._rowSearchCacheByIndexWithoutEmptyValues.clear(),this._rowSearchCacheByTime.clear(),this._rowSearchCacheByTimeWithoutEmptyValues.clear()}}function _(t,e){if(null===t)return e;if(null===e)return t;return{min:Math.min(t.min,e.min),max:Math.max(t.max,e.max)}}},368628:(t,e,s)=>{s.d(e,{SeriesData:()=>_,barFunction:()=>u,seriesPlotFunctionMap:()=>l});var n,r=s(650151),i=s(55243),a=s(828473);!function(t){t[t.FromLeft=-1]="FromLeft",t[t.FromRight=1]="FromRight"}(n||(n={}));const h={open:t=>t[1],high:t=>t[2],low:t=>t[3],close:t=>t[4],hl2:t=>(t[2]+t[3])/2,hlc3:t=>(t[2]+t[3]+t[4])/3,ohlc4:t=>(t[1]+t[2]+t[3]+t[4])/4},o=["open","high","low","close","hl2","hlc3","ohlc4"];function l(){const t=new Map;return o.forEach(((e,s)=>{t.set(e,u(e))})),t
}function u(t,e,s){const n=h[null!=e?e:t],r=h[t],i=h[null!=s?s:t];return(t,e)=>{switch(e){case 0:return n(t);case 2:return i(t);default:return r(t)}}}function c(t,e){return null==t[e]}const d=[{barsToMerge:10,forBarspacingLargerThen:.03},{barsToMerge:30,forBarspacingLargerThen:.01},{barsToMerge:100,forBarspacingLargerThen:.003},{barsToMerge:500,forBarspacingLargerThen:0}];class _{constructor(){this._pressedChunks={chunks:new Map,priceSource:"uninitialized"},this.m_bars=new i.PlotList(l(),c),this.m_nsBars=new i.PlotList(l(),c),this._clearPressedChunks()}bars(){return this.m_bars}nsBars(){return this.m_nsBars}pressedChunks(t,e){if(e!==this._pressedChunks.priceSource){this._pressedChunks.priceSource=e;const t=this.m_bars.first();t&&(this._clearPressedChunks(),this._rebuildPressedChunks(t))}const s=(0,r.ensureDefined)(d.find((e=>e.forBarspacingLargerThen<=t)));return(0,r.ensureDefined)(this._pressedChunks.chunks.get(s.barsToMerge))}mergeRegularBars(t){const e=this.m_bars.size(),s=this.m_bars.merge(t);return s&&"uninitialized"!==this._pressedChunks.priceSource&&(e===this.m_bars.size()&&s.index===this.m_bars.lastIndex()?this._updateLatestChunks():this._rebuildPressedChunks(s)),s}size(){return this.m_bars.size()+this.m_nsBars.size()}each(t){this.m_bars.each(t),this.m_nsBars.each(t)}clear(){this.m_bars.clear(),this.m_nsBars.clear(),this.lastProjectionPrice=void 0,this._clearPressedChunks()}clone(){const t=new _;return t.lastProjectionPrice=this.lastProjectionPrice,t.boxSize=this.boxSize,t.reversalAmount=this.reversalAmount,t.m_bars=this.m_bars.clone(),t.m_nsBars=this.m_bars.clone(),t}isEmpty(){return this.m_bars.isEmpty()&&this.m_nsBars.isEmpty()}first(){return this.m_bars.isEmpty()?this.m_nsBars.first():this.m_bars.first()}last(){return this.m_nsBars.isEmpty()?this.m_bars.last():this.m_nsBars.last()}search(t,e,s){return this.nsBars().isEmpty()?this.bars().search(t,e,s):this.bars().isEmpty()||(0,r.ensureNotNull)(this.nsBars().firstIndex())<=t?this.nsBars().search(t,e,s):this.bars().search(t,e,s)}valueAt(t){const e=this.search(t);return null!==e?e.value:null}plotValueToTimePointIndex(t,e,s){if(s===n.FromRight){const s=(s,n)=>{const r=n[e];return null!=r&&t>=r},n=this.m_bars.findLast(s);if(null!==n)return n.index;const r=this.m_nsBars.findLast(s);return null!==r?r.index:this.m_bars.firstIndex()}if(s===n.FromLeft){const s=(s,n)=>{const r=n[e];return null!=r&&t<=r},n=this.m_bars.findFirst(s);if(null!==n)return n.index;const r=this.m_nsBars.findFirst(s);return null!==r?r.index:this.m_bars.lastIndex()}throw new Error("plotValueToTimePointIndex: unsupported search mode")}moveData(t){this.m_bars.move(t),this.m_nsBars.move(t),this.m_bars.size()>0&&this._rebuildPressedChunks((0,r.ensureNotNull)(this.m_bars.first()))}_rebuildPressedChunks(t){const e=this._pressedChunks.priceSource;if("uninitialized"===e)return;const s=t.index,n=h[e],i=(t,e,s)=>{let r=null;for(const i of t){const t=n(i.value);r&&i.index-r.startTime>=s.barsToMerge&&(e.push(r),r=null),r?(r.endTime=i.index,r.high=Math.max(r.high,t),r.low=Math.min(r.low,t),r.close=t):r={
startTime:i.index,endTime:i.index,open:t,high:t,low:t,close:t}}r&&e.push(r)};d.forEach((t=>{const e=(0,r.ensureDefined)(this._pressedChunks.chunks.get(t.barsToMerge)),n=(0,a.lowerbound)(e,s,((t,e)=>t.endTime<e));if(0===n&&e.length>0){const s=e[0].startTime-1,n=(0,r.ensureNotNull)(this.m_bars.firstIndex()),a=this.m_bars.rangeIterator(n,s),h=[];i(a,h,t);const o=h.concat(e);this._pressedChunks.chunks.set(t.barsToMerge,o)}else{const s=(0,r.ensureNotNull)(this.m_bars.lastIndex());e.splice(n);let a=(0,r.ensureNotNull)(this.m_bars.firstIndex());e.length&&(a=e[e.length-1].endTime+1);const h=this.m_bars.rangeIterator(a,s);i(h,e,t)}}))}_updateLatestChunks(){const t=(0,r.ensureNotNull)(this.m_bars.last());d.forEach((e=>{const s=(0,r.ensureDefined)(this._pressedChunks.chunks.get(e.barsToMerge)),n=t.value[4],i=s[s.length-1];i.high=Math.max(i.high,n),i.low=Math.min(i.low,n),i.close=n,i.endTime=t.index}))}_clearPressedChunks(){d.forEach((t=>this._pressedChunks.chunks.set(t.barsToMerge,[])))}}},362805:(t,e,s)=>{s.d(e,{makeNextStudyId:()=>a,makeNextSymbolId:()=>r});let n=0;function r(){return n++,"ss_"+n}let i=0;function a(){return i++,"st"+i}},955273:(t,e,s)=>{function n(){let t,e;return{promise:new Promise(((s,n)=>{t=s,e=n})),reject:e,resolve:t}}s.d(e,{createDeferredPromise:()=>n})}}]);